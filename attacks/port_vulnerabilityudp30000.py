import logging
from generic_attack import *
from lib import nmap_python
import logging
log = logging.getLogger(__name__)


class PortVulnerabilityTestudp30000(GenericAttack):
    """ARP spoofing class
    """

    def __init__(self, attackName, attackConfig, deviceConfig):
        super(PortVulnerabilityTestudp30000, self).__init__(attackName, attackConfig, deviceConfig)


    def initialize(self, result):
        self.running = True
        nm = nmap_python.PortScanner()
        updateEnabled = False
        # nm.scan(self.device["ip"], '0-65535', arguments='-sS -sU')
        args = "-sU"
        if not self.config["optimization"] == "":
            args = args + " " + self.config["optimization"];
        macAddress = self.device['macAddress']
        if macAddress in self.config.keys() and not macAddress == '':
            result.update(self.config[macAddress])
            updateEnabled = True

        if not self.config['skip']:
            nm.scan(self.device["ip"], self.config["port_range"], arguments=args, sudo=True, scan=True)

            for host in nm.all_hosts():
                # log.info('----------------------------------------------------')
                # log.info('Host : %s (%s)' % (host, nm[host].hostname()))
                # log.info('State : %s' % nm[host].state())
                for proto in nm[host].all_protocols():
                    # print('----------')
                    # print('Protocol : %s' % proto)
                    lport = nm[host][proto].keys()
                    lport.sort()
                    proto_ports_open = []
                    proto_ports_filtered = []
                    for port in lport:
                        if(nm[host][proto][port]['state'] == "open"):
                            proto_ports_open.append(port)
                        elif (nm[host][proto][port]['state'] == "open|filtered"):
                            proto_ports_filtered.append(port)
                        # print ('port : %s\tstate : %s' % (port, nm[host][proto][port]['state']))
                    if updateEnabled:
                        if proto in result.keys():
                            if "open" in result[proto].keys():
                                portRange = self.config["port_range"].split("-")
                                for openPort in result[proto]['open']:
                                    if openPort >= int(portRange[0]) and openPort<=int(portRange[1]):
                                        result[proto]['open'].remove(openPort)
                                result[proto]['open'].extend(proto_ports_open)
                                result[proto]['open'].extend(proto_ports_filtered)
                            else:
                                result[proto].update({"open": proto_ports_open})
                                result[proto].update({"open": proto_ports_filtered})

                                # if "filtered" in result[proto].keys():
                            #     portRange = self.config["port_range"].split("-")
                            #     for filteredPort in result[proto]['filtered']:
                            #         if filteredPort >= int(portRange[0]) and openPort<=int(portRange[1]):
                            #             result[proto]['filtered'].remove(filteredPort)
                            #     result[proto]['filtered'].extend(proto_ports_filtered)
                            # else:
                            #     result[proto].update({"open": proto_ports_open})

                        else:
                            # result.update({proto: {"open": proto_ports_open, "filtered": proto_ports_filtered}})
                            result.update({proto: {"open": proto_ports_open}})
                    else:
                        # result.update({proto: {"open":proto_ports_open, "filtered":proto_ports_filtered}})
                        result.update({proto: {"open": proto_ports_open}})
        log.info(result)
        self.device.update({"vulnerable_ports": result})
        return

    def shutdown(self):
        self.running = False
        return True

